import re
from pyrogram import filters, Client, enums
from pyrogram.errors.exceptions.bad_request_400 import ChannelInvalid, UsernameInvalid, UsernameNotModified
from pyrogram.errors import ChannelInvalid, UsernameInvalid, UsernameNotModified
from config import ADMINS, LOG_CHANNEL, PUBLIC_FILE_STORE, WEBSITE_URL, WEBSITE_URL_MODE
from plugins.users_api import get_user, get_short_link
import re
import os
import json
import base64
import requests
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton

async def allowed(_, __, message):
    if PUBLIC_FILE_STORE:
        return True
    if message.from_user and message.from_user.id in ADMINS:
        return True
    return False

@Client.on_message((filters.document | filters.video | filters.audio) & filters.private & filters.create(allowed))
async def incoming_gen_link(bot, message):
    username = (await bot.get_me()).username
    file_type = message.media
    post = await message.copy(LOG_CHANNEL)
    file_id = str(post.id)
    string = 'file_'
    string += file_id
    outstr = base64.urlsafe_b64encode(string.encode("ascii")).decode().strip("=")
    user_id = message.from_user.id
    user = await get_user(user_id)
    if WEBSITE_URL_MODE == True:
        share_link = f"{WEBSITE_URL}?start={outstr}"
    else:
        share_link = f"https://t.me/{username}?start={outstr}"
    if user["base_site"] and user["shortener_api"] != None:
        short_link = await get_short_link(user, share_link)
        await message.reply(f"<b>‚≠ï  ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä  ü…™…¥·¥ã:\n\nüñáÔ∏è s ú·¥è Ä·¥õ  ü…™…¥·¥ã :- {short_link}</b>")
    else:
        await message.reply(f"<b>‚≠ï  ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä  ü…™…¥·¥ã:\n\nüîó ·¥è Ä…™…¢…™…¥·¥Ä ü  ü…™…¥·¥ã :- {share_link}</b>")
        

@Client.on_message(filters.command(['link']) & filters.create(allowed))
async def gen_link_s(bot, message):
    username = (await bot.get_me()).username
    replied = message.reply_to_message
    if not replied:
        return await message.reply('Reply to a message to get a shareable link.')
        
    post = await replied.copy(LOG_CHANNEL)
    file_id = str(post.id)
    string = f"file_"
    string += file_id
    outstr = base64.urlsafe_b64encode(string.encode("ascii")).decode().strip("=")
    user_id = message.from_user.id
    user = await get_user(user_id)
    if WEBSITE_URL_MODE == True:
        share_link = f"{WEBSITE_URL}?start={outstr}"
    else:
        share_link = f"https://t.me/{username}?start={outstr}"
    if user["base_site"] and user["shortener_api"] != None:
        short_link = await get_short_link(user, share_link)
        await message.reply(f"<b>‚≠ï  ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä  ü…™…¥·¥ã:\n\nüñáÔ∏è s ú·¥è Ä·¥õ  ü…™…¥·¥ã :- {short_link}</b>")
    else:
        await message.reply(f"<b>‚≠ï  ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä  ü…™…¥·¥ã:\n\nüîó ·¥è Ä…™…¢…™…¥·¥Ä ü  ü…™…¥·¥ã :- {share_link}</b>")

#OMDB_API_KEY = "7cd62fdc"

@Client.on_message(filters.command(['batch']) & filters.create(allowed))
async def gen_link_batch(bot, message):
    username = (await bot.get_me()).username
    if " " not in message.text:
        return await message.reply("Use correct format.\nExample /batch https://t.me/vj_botz/10 https://t.me/vj_botz/20.")
    links = message.text.strip().split(" ")
    if len(links) != 3:
        return await message.reply("Use correct format.\nExample /batch https://t.me/vj_botz/10 https://t.me/vj_botz/20.")
    cmd, first, last = links
    regex = re.compile("(https://)?(t\.me/|telegram\.me/|telegram\.dog/)(c/)?(\d+|[a-zA-Z_0-9]+)/(\d+)$")
    match = regex.match(first)
    if not match:
        return await message.reply('Invalid link')
    f_chat_id = match.group(4)
    f_msg_id = int(match.group(5))
    if f_chat_id.isnumeric():
        f_chat_id = int(("-100" + f_chat_id))
    
    match = regex.match(last)
    if not match:
        return await message.reply('Invalid link')
    l_chat_id = match.group(4)
    l_msg_id = int(match.group(5))
    if l_chat_id.isnumeric():
        l_chat_id = int(("-100" + l_chat_id))

    if f_chat_id != l_chat_id:
        return await message.reply("Chat ids not matched.")
    try:
        chat_id = (await bot.get_chat(f_chat_id)).id
    except ChannelInvalid:
        return await message.reply('This may be a private channel / group. Make me an admin over there to index the files.')
    except (UsernameInvalid, UsernameNotModified):
        return await message.reply('Invalid Link specified.')
    except Exception as e:
        return await message.reply(f'Errors - {e}')
    
    sts = await message.reply("**…¢·¥á…¥·¥á Ä·¥Ä·¥õ…™…¥…¢  ü…™…¥·¥ã “ì·¥è Ä  è·¥è·¥ú Ä ·¥ç·¥áss·¥Ä…¢·¥á**.\n**·¥õ ú…™s ·¥ç·¥Ä è ·¥õ·¥Ä·¥ã·¥á ·¥õ…™·¥ç·¥á ·¥Ö·¥á·¥ò·¥á…¥·¥Ö…™…¥…¢ ·¥ú·¥ò·¥è…¥ …¥·¥ú·¥ç ô·¥á Ä ·¥è“ì ·¥ç·¥áss·¥Ä…¢·¥ás**")

    FRMT = "**…¢·¥á…¥·¥á Ä·¥Ä·¥õ…™…¥…¢  ü…™…¥·¥ã...**\n**·¥õ·¥è·¥õ·¥Ä ü ·¥ç·¥áss·¥Ä…¢·¥ás:** {total}\n**·¥Ö·¥è…¥·¥á:** {current}\n** Ä·¥á·¥ç·¥Ä…™…¥…™…¥…¢:** {rem}\n**s·¥õ·¥Ä·¥õ·¥ús:** {sts}"

    outlist = []

    # file store without db channel
    og_msg = 0
    tot = 0
    async for msg in bot.iter_messages(f_chat_id, l_msg_id, f_msg_id):
        tot += 1
        if og_msg % 20 == 0:
            try:
                await sts.edit(FRMT.format(total=l_msg_id-f_msg_id, current=tot, rem=((l_msg_id-f_msg_id) - tot), sts="Saving Messages"))
            except:
                pass
        if msg.empty or msg.service:
            continue
        file = {
            "channel_id": f_chat_id,
            "msg_id": msg.id
        }
        og_msg +=1
        outlist.append(file)

    with open(f"batchmode_{message.from_user.id}.json", "w+") as out:
        json.dump(outlist, out)
    post = await bot.send_document(LOG_CHANNEL, f"batchmode_{message.from_user.id}.json", file_name="Batch.json", caption="‚ö†Ô∏è Batch Generated For Filestore.")
    os.remove(f"batchmode_{message.from_user.id}.json")
    string = str(post.id)
    file_id = base64.urlsafe_b64encode(string.encode("ascii")).decode().strip("=")
    user_id = message.from_user.id
    user = await get_user(user_id)
    if WEBSITE_URL_MODE == True:
        share_link = f"{WEBSITE_URL}?Tech_VJ=BATCH-{file_id}"
    else:
        share_link = f"https://t.me/{username}?start=BATCH-{file_id}"
    if user["base_site"] and user["shortener_api"] != None:
        short_link = await get_short_link(user, share_link)
        await sts.edit(f"<b>‚≠ï  ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä  ü…™…¥·¥ã:\n\nContains `{og_msg}` files.\n\nüñáÔ∏è s ú·¥è Ä·¥õ  ü…™…¥·¥ã :- {short_link}</b>")
    else:
        await sts.edit(f"<b>‚≠ï  ú·¥á Ä·¥á …™s  è·¥è·¥ú Ä  ü…™…¥·¥ã:\n\nContains `{og_msg}` files.\n\nüîó ·¥è Ä…™…¢…™…¥·¥Ä ü  ü…™…¥·¥ã :- {share_link}</b>")

#--------------------------------------------New Code---------------------------------------------------#
from pyrogram import Client, filters
import re
import json
import os
import base64
import requests
from imdb import IMDb

# Initialize IMDb instance
imdb = IMDb()

# Store user state for linking movie input with batch link
user_data = {}

@Client.on_message(filters.command(['postup']))
async def gen_link_batch(bot, message):
    username = (await bot.get_me()).username

    if " " not in message.text:
        return await message.reply("Use correct format.\nExample: `/postup https://t.me/vj_botz/10 https://t.me/vj_botz/20`")
    
    links = message.text.strip().split(" ")
    if len(links) != 3:
        return await message.reply("Use correct format.\nExample: `/postup https://t.me/vj_botz/10 https://t.me/vj_botz/20`")
    
    _, first, last = links
    
    regex = re.compile(r"(https://)?t\.me/([a-zA-Z_0-9]+)/(\d+)")
    
    match_first = regex.match(first)
    match_last = regex.match(last)
    
    if not match_first or not match_last:
        return await message.reply('Invalid link format.')
    
    chat_username = match_first.group(2)
    f_msg_id = int(match_first.group(3))
    l_msg_id = int(match_last.group(3))

    try:
        chat = await bot.get_chat(chat_username)
        chat_id = chat.id
    except Exception as e:
        return await message.reply(f'Error: {e}')

    sts = await message.reply("**Generating link for your messages...**")
    
    outlist = []
    
    async for msg in bot.iter_messages(chat_id, l_msg_id, f_msg_id):
        if msg.empty or msg.service:
            continue
        file = {"channel_id": chat_id, "msg_id": msg.id}
        outlist.append(file)
    
    json_filename = f"batchmode_{message.from_user.id}.json"
    with open(json_filename, "w") as out:
        json.dump(outlist, out)
    
    post = await bot.send_document("LOG_CHANNEL", json_filename, file_name="Batch.json", caption="Batch Generated For Filestore.")
    
    os.remove(json_filename)

    file_id = base64.urlsafe_b64encode(str(post.id).encode("ascii")).decode().strip("=")
    share_link = f"https://t.me/{username}?start=BATCH-{file_id}"

    user_data[message.from_user.id] = share_link  # Store for later use

    await sts.edit("Batch link generated! Now send me the movie title and year in format: `Title (Year)`.\nExample: `Inception (2010)`")

@Client.on_message(filters.text & filters.private)
async def get_movie_details(bot, msg):
    user_id = msg.from_user.id
    if user_id not in user_data:
        return await msg.reply("Please generate a batch link first using `/postup`.")

    text = msg.text.strip()
    match = re.match(r"(.+) \((\d{4})\)", text)
    if not match:
        return await msg.reply("Invalid format! Please use: `Title (Year)`.\nExample: `Inception (2010)`")
    
    title, year = match.groups()
    search_results = imdb.search_movie(title)
    
    if not search_results:
        return await msg.reply("Movie not found on IMDb.")
    
    movie = imdb.get_movie(search_results[0].movieID)
    poster_url = movie.get('full-size cover url', "https://via.placeholder.com/300x450.png?text=No+Poster")

    share_link = user_data.pop(user_id)  # Retrieve and remove stored link

    await bot.send_photo(
        chat_id=msg.chat.id,
        photo=poster_url,
        caption=f"üé¨ *{title} ({year})*\n"
                f"‚≠ê Rating: {movie.get('rating', 'N/A')}\n"
                f"üìå Genres: {', '.join(movie.get('genres', []))}\n"
                f"üìù Plot: {movie.get('plot outline', 'N/A')}\n\n"
                f"[Download Here]({share_link})",
        parse_mode="Markdown"
    )

#---------------------------------IMDB--------------------------------------#

async def get_poster(query, bulk=False, id=False, file=None):
    if not id:
        query = query.strip().lower()
        title = query
        year = re.findall(r'[1-2]\d{3}$', query, re.IGNORECASE)
        if year:
            year = list_to_str(year[:1])
            title = (query.replace(year, "")).strip()
        elif file is not None:
            year = re.findall(r'[1-2]\d{3}', file, re.IGNORECASE)
            if year:
                year = list_to_str(year[:1])
        else:
            year = None
        movieid = imdb.search_movie(title.lower(), results=10)
        if not movieid:
            return None
        if year:
            filtered = list(filter(lambda k: str(k.get('year')) == str(year), movieid))
            if not filtered:
                filtered = movieid
        else:
            filtered = movieid
        movieid = list(filter(lambda k: k.get('kind') in ['movie', 'tv series'], filtered))
        if not movieid:
            movieid = filtered
        if bulk:
            return movieid
        movieid = movieid[0].movieID
    else:
        movieid = query
    movie = imdb.get_movie(movieid)
    if movie.get("original air date"):
        date = movie["original air date"]
    elif movie.get("year"):
        date = movie.get("year")
    else:
        date = "N/A"
    plot = ""
    if not True:  # Replace True with the condition you want
        plot = movie.get('plot')
        if plot and len(plot) > 0:
            plot = plot[0]
    else:
        plot = movie.get('plot outline')
    if plot and len(plot) > 800:
        plot = plot[0:800] + "..."

    return {
        'title': movie.get('title'),
        'votes': movie.get('votes'),
        "aka": list_to_str(movie.get("akas")),
        "seasons": movie.get("number of seasons"),
        "box_office": movie.get('box office'),
        'localized_title': movie.get('localized title'),
        'kind': movie.get("kind"),
        "imdb_id": f"tt{movie.get('imdbID')}",
        "cast": list_to_str(movie.get("cast")),
        "runtime": list_to_str(movie.get("runtimes")),
        "countries": list_to_str(movie.get("countries")),
        "certificates": list_to_str(movie.get("certificates")),
        "languages": list_to_str(movie.get("languages")),
        "director": list_to_str(movie.get("director")),
        "writer": list_to_str(movie.get("writer")),
        "producer": list_to_str(movie.get("producer")),
        "composer": list_to_str(movie.get("composer")),
        "cinematographer": list_to_str(movie.get("cinematographer")),
        "music_team": list_to_str(movie.get("music department")),
        "distributors": list_to_str(movie.get("distributors")),
        'release_date': date,
        'year': movie.get('year'),
        'genres': list_to_str(movie.get("genres")),
        'poster': movie.get('full-size cover url'),
        'plot': plot,
        'rating': str(movie.get("rating")),
        'url': f'https://www.imdb.com/title/tt{movieid}'
    }


@Bot.on_message(filters.command('imdb') & filters.private)
async def imdb_command(bot: bot, message: Message):
    if len(message.command) < 2:
        await message.reply("Please provide a movie name with the /imdb command.")
        return

    movie_name = ' '.join(message.command[1:])
    
    try:
        poster_info = await get_poster(movie_name)
        
        if poster_info:
            # Download the poster image
            image_response = requests.get(poster_info['poster'])
            image_data = io.BytesIO(image_response.content)

            # Send the poster image as a photo along with other details
            await bot.send_photo(
                chat_id=message.chat.id,
                photo=image_data,
                caption=f'Movie Poster for {poster_info["title"]}\n'
                        f'Rating: {poster_info["rating"]}\n'
                        f'Genres: {poster_info["genres"]}\n'
                        f'Plot: {poster_info["plot"]}\n'
                        f'IMDb URL: {poster_info["url"]}'
            )

        else:
            await message.reply_text('Movie not found. Please check the movie name and try again.')
